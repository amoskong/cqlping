#!/usr/bin/env python

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#
# See LICENSE for more details.
#
# Copyright (c) 2017 ScyllaDB

import sys
import socket
import time
import argparse
import random
import string
import logging

from cassandra.policies import WhiteListRoundRobinPolicy
from cassandra.cluster import ExecutionProfile
from cassandra.cluster import EXEC_PROFILE_DEFAULT
from cassandra.cluster import Cluster
from cassandra.cluster import NoHostAvailable
from cassandra.auth import PlainTextAuthProvider


logger = logging.getLogger('cqlping')
logger.setLevel(logging.INFO)
handler = logging.StreamHandler(sys.stdout)
logger.addHandler(handler)

# Global connect session
_session = None

def get_session(ip, port, username, password):
    if username is not None:
        auth_provider = PlainTextAuthProvider(username=username, password=password)
    else:
        auth_provider = None

    try:
        profiles = {EXEC_PROFILE_DEFAULT: ExecutionProfile(load_balancing_policy=WhiteListRoundRobinPolicy([ip]))}
        cluster = Cluster([ip], port=port, auth_provider=auth_provider, execution_profiles=profiles)
        session = cluster.connect()
        return session
    except NoHostAvailable as e:
        logger.error(e.errors.values()[0])
        sys.exit(1)

def prepare_session(ip, port=9042, username=None, password=None):
    global _session
    _session = get_session(ip, port, username, password)

def prepare_default_schema():
    _session.execute("CREATE KEYSPACE IF NOT EXISTS cqlping WITH replication = {'class':'SimpleStrategy', 'replication_factor':1}")
    _session.execute("CREATE TABLE IF NOT EXISTS cqlping.cf (key1 bigint, key2 bigint, val blob, PRIMARY KEY(key1, key2))")

def get_packet_size(row):
    l = 0
    for i in row:
        if isinstance(i, int):
            l += 2
        elif isinstance(i, str) or isinstance(i, unicode):
            l += len(i)
    return l

def do_cql_ping(size, ttl, request_query=None, reply_query=None):
    global _session

    # emulate random delay
    #import random
    #n = random.randint(0, 100)
    #time.sleep( n / 100.0)
    (time_int1, time_int2) = time.time().as_integer_ratio()

    # ping request
    args_list = []
    if request_query is None:
        request_query = "INSERT INTO cqlping.cf (key1, key2, val) VALUES (%s, %s, textAsBlob('%s'))"
        args_list =  [time_int1, time_int2]
    if '%s' in request_query:
        random_str = ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(size))
        args_list.append(random_str)
        request_query = request_query % tuple(args_list)
    if ttl:
        request_query += " USING TTL %s" % ttl

    logger.debug(request_query)
    _session.execute(request_query)

    # pong reply
    if reply_query is None:
        reply_query = 'select * from cqlping.cf where key1 = %s and key2 = %s' % (time_int1, time_int2)
    logger.debug(reply_query)
    ret = _session.execute(reply_query)
    #help(ret)
    rows = list(_session.execute(reply_query))
    logger.debug(rows)
    logger.debug('reply data length: %d', get_packet_size(rows[0]))
    return get_packet_size(rows[0])


if __name__ == "__main__":

    parser = argparse.ArgumentParser(description="CQLPing - Simple CQL I/O latency monitoring tool")
    parser.add_argument('--debug', action="store_true", help="Enable debug mode")
    parser.add_argument('-c', action="store", help="Stop after sending count ECHO_REQUEST packets", default=4)
    parser.add_argument('-i', action="store", help="Wait interval seconds between each sending packet", default=1)
    parser.add_argument('--cqlport', action="store", help="CQL port", default=9042)
    parser.add_argument('--cqluser', action="store", help="CQL username")
    parser.add_argument('--cqlpwd', action="store", help="CQL password")
    parser.add_argument('--request-query', action="store", help="Request query", default=None)
    parser.add_argument('--reply-query', action="store", help="Reply query", default=None)
    parser.add_argument('-t', action="store", help="Time to live", default=64) #FIXME: unimplement
    parser.add_argument('-s', action="store", help="Size of random packet", default=None)
    parser.add_argument('destination', action="store", help="CqlPing packet destination", default='localhost')
    args = parser.parse_args()

    if args.debug:
        logger.setLevel(logging.DEBUG)
        fmt = logging.Formatter(fmt='%(name)s %(levelname)s: %(message)s')
        handler.setFormatter(fmt=fmt)

    ip = socket.gethostbyname(args.destination)

    dest_str = "%s (%s)" % (args.destination, ip)

    logger.info("CQLPing %s, preparing...", dest_str)

    interval = float(args.i)

    prepare_session(ip, port=int(args.cqlport), username=args.cqluser, password=args.cqlpwd)

    if (args.request_query is None) ^ (args.reply_query is None):
        logger.error("request-query and replay-query should be assigned together")
        sys.exit(1)
    if args.request_query is None and args.reply_query is None:
        logger.info("Prepare default schema cqlping.cf (key1 bigint, key2 bigint, val blob, PRIMARY KEY(key1, key2))")
        prepare_default_schema()
        if args.s is None:
            args.s = 60
    elif args.s and '%s' not in args.request_query:
        logger.error("packet size is assigned, but there is no '%s' in request-query")
        sys.exit(1)
    elif args.s is None and '%s' in args.request_query:
        logger.error("request-query contains '%s', please assign packet size by `-s`")
        sys.exit(1)

    data_size = int(args.s) if args.s else 0

    try:
        seq = 1
        for i in range(int(args.c)):
            start_time = time.time()
            ret_size = do_cql_ping(data_size, int(args.t), args.request_query, args.reply_query)
            delta = time.time() - start_time
            if delta < interval:
                time.sleep(interval - delta)
            logger.info("%d bytes %s seq=%d ttl=%s time=%.3f ms" % (ret_size, dest_str, seq, args.t, delta))
            seq += 1
    except KeyboardInterrupt as e:
        sys.exit(1)
